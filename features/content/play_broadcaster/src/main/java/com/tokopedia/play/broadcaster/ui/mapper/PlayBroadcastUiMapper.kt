package com.tokopedia.play.broadcaster.ui.mapper

import com.tokopedia.broadcaster.revamp.util.statistic.BroadcasterMetric
import com.tokopedia.byteplus.effect.util.asset.checker.AssetChecker
import com.tokopedia.content.common.model.Creation
import com.tokopedia.content.common.track.response.GetReportSummaryResponse
import com.tokopedia.content.common.types.ContentCommonUserType.TYPE_SHOP
import com.tokopedia.content.common.types.ContentCommonUserType.TYPE_USER
import com.tokopedia.content.common.ui.model.ContentAccountUiModel
import com.tokopedia.content.common.ui.model.TermsAndConditionUiModel
import com.tokopedia.kotlin.extensions.toFormattedString
import com.tokopedia.play.broadcaster.domain.model.Banned
import com.tokopedia.play.broadcaster.domain.model.Chat
import com.tokopedia.play.broadcaster.domain.model.Config
import com.tokopedia.play.broadcaster.domain.model.CreateLiveStreamChannelResponse
import com.tokopedia.play.broadcaster.domain.model.Freeze
import com.tokopedia.play.broadcaster.domain.model.GetChannelResponse
import com.tokopedia.play.broadcaster.domain.model.GetLiveStatisticsResponse
import com.tokopedia.play.broadcaster.domain.model.NewMetricList
import com.tokopedia.play.broadcaster.domain.model.TotalLike
import com.tokopedia.play.broadcaster.domain.model.TotalView
import com.tokopedia.play.broadcaster.domain.model.autogeneratedcover.GetGeneratedImageCoverResponse
import com.tokopedia.play.broadcaster.domain.model.config.GetBroadcastingConfigurationResponse
import com.tokopedia.play.broadcaster.domain.model.interactive.GetInteractiveConfigResponse
import com.tokopedia.play.broadcaster.domain.model.interactive.GetSellerLeaderboardSlotResponse
import com.tokopedia.play.broadcaster.domain.model.interactive.PostInteractiveCreateSessionResponse
import com.tokopedia.play.broadcaster.domain.model.interactive.quiz.GetInteractiveQuizChoiceDetailResponse
import com.tokopedia.play.broadcaster.domain.model.interactive.quiz.GetInteractiveQuizDetailResponse
import com.tokopedia.play.broadcaster.domain.model.pinnedmessage.GetPinnedMessageResponse
import com.tokopedia.play.broadcaster.domain.model.report.product.GetReportProductSummaryResponse
import com.tokopedia.play.broadcaster.domain.model.socket.PinnedMessageSocketResponse
import com.tokopedia.play.broadcaster.domain.usecase.interactive.quiz.PostInteractiveCreateQuizUseCase
import com.tokopedia.play.broadcaster.domain.usecase.livetovod.GetTickerBottomSheetResponse
import com.tokopedia.play.broadcaster.pusher.statistic.PlayBroadcasterMetric
import com.tokopedia.play.broadcaster.ui.model.BroadcastScheduleConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.BroadcastScheduleUiModel
import com.tokopedia.play.broadcaster.ui.model.ChannelInfoUiModel
import com.tokopedia.play.broadcaster.ui.model.ChannelStatus
import com.tokopedia.play.broadcaster.ui.model.ChannelSummaryUiModel
import com.tokopedia.play.broadcaster.ui.model.ConfigurationUiModel
import com.tokopedia.play.broadcaster.ui.model.CoverConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.CoverSource
import com.tokopedia.play.broadcaster.ui.model.DurationConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.EventUiModel
import com.tokopedia.play.broadcaster.ui.model.LiveStreamInfoUiModel
import com.tokopedia.play.broadcaster.ui.model.PlayCoverUiModel
import com.tokopedia.play.broadcaster.ui.model.PlayMetricUiModel
import com.tokopedia.play.broadcaster.ui.model.ProductTagConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.ShareUiModel
import com.tokopedia.play.broadcaster.ui.model.TotalLikeUiModel
import com.tokopedia.play.broadcaster.ui.model.TotalViewUiModel
import com.tokopedia.play.broadcaster.ui.model.TrafficMetricType
import com.tokopedia.play.broadcaster.ui.model.TrafficMetricUiModel
import com.tokopedia.play.broadcaster.ui.model.autogeneratedcover.GeneratedCoverUiModel
import com.tokopedia.play.broadcaster.ui.model.beautification.BeautificationAssetStatus
import com.tokopedia.play.broadcaster.ui.model.beautification.BeautificationConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.beautification.FaceFilterUiModel
import com.tokopedia.play.broadcaster.ui.model.beautification.PresetFilterUiModel
import com.tokopedia.play.broadcaster.ui.model.config.BroadcastingConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.game.GameParticipantUiModel
import com.tokopedia.play.broadcaster.ui.model.game.quiz.QuizChoiceDetailUiModel
import com.tokopedia.play.broadcaster.ui.model.game.quiz.QuizDetailDataUiModel
import com.tokopedia.play.broadcaster.ui.model.game.quiz.QuizFormDataUiModel
import com.tokopedia.play.broadcaster.ui.model.interactive.GiveawayConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.interactive.InteractiveConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.interactive.InteractiveSessionUiModel
import com.tokopedia.play.broadcaster.ui.model.interactive.QuizConfigUiModel
import com.tokopedia.play.broadcaster.ui.model.livetovod.TickerBottomSheetPage
import com.tokopedia.play.broadcaster.ui.model.livetovod.TickerBottomSheetType
import com.tokopedia.play.broadcaster.ui.model.livetovod.TickerBottomSheetUiModel
import com.tokopedia.play.broadcaster.ui.model.pinnedmessage.PinnedMessageEditStatus
import com.tokopedia.play.broadcaster.ui.model.pinnedmessage.PinnedMessageUiModel
import com.tokopedia.play.broadcaster.ui.model.report.live.LiveReportSummaryUiModel
import com.tokopedia.play.broadcaster.ui.model.report.live.LiveStatsUiModel
import com.tokopedia.play.broadcaster.ui.model.report.product.ProductReportSummaryUiModel
import com.tokopedia.play.broadcaster.ui.model.report.product.ProductStatsUiModel
import com.tokopedia.play.broadcaster.util.extension.DATE_FORMAT_BROADCAST_SCHEDULE
import com.tokopedia.play.broadcaster.util.extension.DATE_FORMAT_RFC3339
import com.tokopedia.play.broadcaster.util.extension.toDateWithFormat
import com.tokopedia.play.broadcaster.util.helper.UriParser
import com.tokopedia.play.broadcaster.view.state.CoverSetupState
import com.tokopedia.play.broadcaster.view.state.SetupDataState
import com.tokopedia.play_common.model.ui.LeadeboardType
import com.tokopedia.play_common.model.ui.LeaderboardGameUiModel
import com.tokopedia.play_common.model.ui.PlayChatUiModel
import com.tokopedia.play_common.model.ui.QuizChoicesUiModel
import com.tokopedia.play_common.transformer.HtmlTextTransformer
import com.tokopedia.play_common.view.game.quiz.PlayQuizOptionState
import java.util.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject

/**
 * Created by jegul on 02/06/20
 */
class PlayBroadcastUiMapper @Inject constructor(
    private val textTransformer: HtmlTextTransformer,
    private val uriParser: UriParser,
    private val assetChecker: AssetChecker,
) : PlayBroadcastMapper {

    override fun mapBroadcastingConfig(response: GetBroadcastingConfigurationResponse): BroadcastingConfigUiModel {
        return BroadcastingConfigUiModel(
            audioRate = response.broadcasterGetBroadcastingConfig.config.audioRate,
            bitrateMode = response.broadcasterGetBroadcastingConfig.config.bitrateMode,
            fps = response.broadcasterGetBroadcastingConfig.config.fps,
            maxRetry = response.broadcasterGetBroadcastingConfig.config.maxRetry,
            reconnectDelay = response.broadcasterGetBroadcastingConfig.config.reconnectDelay,
            videoBitrate = response.broadcasterGetBroadcastingConfig.config.videoBitrate,
            videoHeight = response.broadcasterGetBroadcastingConfig.config.videoHeight,
            videoWidth = response.broadcasterGetBroadcastingConfig.config.videoWidth,
        )
    }

    override fun mapLiveStream(channelId: String, media: CreateLiveStreamChannelResponse.GetMedia) =
        LiveStreamInfoUiModel(ingestUrl = media.ingestUrl)

    override fun mapToLiveTrafficUiMetrics(
        authorType: String,
        metrics: GetLiveStatisticsResponse.ReportChannelSummary
    ): List<TrafficMetricUiModel> {
        return when (authorType) {
            TYPE_SHOP -> mapToLiveTrafficUiMetricsShop(metrics.channel.metrics)
            TYPE_USER -> mapToLiveTrafficUiMetricsUser(metrics.channel.userMetrics)
            else -> emptyList()
        }
    }

    private fun mapToLiveTrafficUiMetricsShop(metrics: GetLiveStatisticsResponse.ReportSellerChannelMetric): List<TrafficMetricUiModel> {
        return mutableListOf(
            TrafficMetricUiModel(TrafficMetricType.TotalViews, metrics.visitChannel),
            TrafficMetricUiModel(
                TrafficMetricType.MaximumConcurrentViews,
                metrics.maxConcurrentUsers
            ),
            TrafficMetricUiModel(TrafficMetricType.VideoLikes, metrics.likeChannel),
            TrafficMetricUiModel(TrafficMetricType.NewFollowers, metrics.followShop),
            TrafficMetricUiModel(TrafficMetricType.ProductVisit, metrics.visitPdp),
            TrafficMetricUiModel(TrafficMetricType.ShopVisit, metrics.visitShop),
            TrafficMetricUiModel(TrafficMetricType.NumberOfAtc, metrics.addToCart),
            TrafficMetricUiModel(TrafficMetricType.NumberOfPaidOrders, metrics.productSoldQuantity)
        )
    }

    private fun mapToLiveTrafficUiMetricsUser(metrics: GetLiveStatisticsResponse.ReportUserChannelMetric): List<TrafficMetricUiModel> {
        return mutableListOf(
            TrafficMetricUiModel(TrafficMetricType.TotalViews, metrics.visitChannel),
            TrafficMetricUiModel(
                TrafficMetricType.MaximumConcurrentViews,
                metrics.maxConcurrentUsers
            ),
            TrafficMetricUiModel(TrafficMetricType.VideoLikes, metrics.likeChannel),
            TrafficMetricUiModel(TrafficMetricType.NewFollowers, metrics.followProfile),
            TrafficMetricUiModel(TrafficMetricType.ProductVisit, metrics.visitPdp),
            TrafficMetricUiModel(TrafficMetricType.ProfileVisit, metrics.visitProfile),
            TrafficMetricUiModel(TrafficMetricType.NumberOfAtc, metrics.addToCart),
            TrafficMetricUiModel(TrafficMetricType.NumberOfPaidOrders, metrics.productSoldQuantity)
        )
    }

    override fun mapTotalView(totalView: TotalView): TotalViewUiModel = TotalViewUiModel(
        totalView.totalViewFmt
    )

    override fun mapTotalLike(totalLike: TotalLike): TotalLikeUiModel =
        TotalLikeUiModel(totalLike.totalLikeFmt)

    override fun mapNewMetricList(metric: NewMetricList): List<PlayMetricUiModel> =
        metric.metricList.map {
            PlayMetricUiModel(
                iconUrl = it.icon,
                spannedSentence = textTransformer.transform(it.sentence),
                type = it.metricType,
                interval = it.interval
            )
        }

    override suspend fun mapConfiguration(config: Config): ConfigurationUiModel {
        val channelStatus = ChannelStatus.getChannelType(
            config.activeLiveChannel,
            config.pausedChannel,
            config.draftChannel,
            config.completeDraft
        )

        val remainingDuration = when (channelStatus.second) {
            ChannelStatus.Live -> config.maxDuration - config.activeChannelRemainingDuration
            ChannelStatus.Pause -> config.maxDuration - config.pausedChannelRemainingDuration
            else -> 0
        }

        return ConfigurationUiModel(
            streamAllowed = config.streamAllowed,
            shortVideoAllowed = config.shortVideoAllowed,
            hasContent = config.hasContent,
            channelId = channelStatus.first,
            channelStatus = channelStatus.second,
            durationConfig = DurationConfigUiModel(
                remainingDuration = TimeUnit.SECONDS.toMillis(remainingDuration),
                maxDuration = TimeUnit.SECONDS.toMillis(config.maxDuration),
                maxDurationDesc = config.maxDurationDesc,
                pauseDuration = TimeUnit.SECONDS.toMillis(config.maxPauseDuration),
            ),
            productTagConfig = ProductTagConfigUiModel(
                maxProduct = config.maxTaggedProduct,
                minProduct = config.minTaggedProduct,
                maxProductDesc = config.maxTaggedProductDesc,
                errorMessage = config.maxTaggedProductDesc
            ),
            coverConfig = CoverConfigUiModel(
                maxChars = config.maxTitleLength
            ),
            countDown = config.countdownSec,
            scheduleConfig = BroadcastScheduleConfigUiModel(
                minimum = config.scheduledTime.minimum.toDateWithFormat(DATE_FORMAT_RFC3339),
                maximum = config.scheduledTime.maximum.toDateWithFormat(DATE_FORMAT_RFC3339),
                default = config.scheduledTime.default.toDateWithFormat(DATE_FORMAT_RFC3339)
            ),
            tnc = config.tnc.map {
                TermsAndConditionUiModel(desc = it.description)
            },
            beautificationConfig = BeautificationConfigUiModel(
                licenseLink = config.beautificationConfig.license,
                modelLink = config.beautificationConfig.model,
                customFaceAssetLink = config.beautificationConfig.customFace.assetAndroid,
                faceFilters = config.beautificationConfig.customFace.menu.map { menu ->
                    val isRemoveEffectActive =
                        config.beautificationConfig.customFace.menu.firstOrNull { it.active && it.id == FaceFilterUiModel.Type.None.id } != null

                    FaceFilterUiModel(
                        id = menu.id,
                        name = menu.name,
                        active = when {
                            isRemoveEffectActive -> false
                            else -> menu.active
                        },
                        minValue = menu.minValue,
                        maxValue = menu.maxValue,
                        defaultValue = menu.defaultValue,
                        value = menu.value,
                        isSelected = isRemoveEffectActive && menu.id == FaceFilterUiModel.Type.None.id,
                    )
                },
                presets = config.beautificationConfig.presets.map { preset ->
                    PresetFilterUiModel(
                        id = preset.id,
                        name = preset.name,
                        active = preset.active,
                        minValue = preset.minValue,
                        maxValue = preset.maxValue,
                        defaultValue = preset.defaultValue,
                        value = preset.value,
                        iconUrl = preset.urlIcon,
                        assetLink = preset.assetLink,
                        assetStatus = if (PresetFilterUiModel.isNone(preset.id) || assetChecker.isPresetFileAvailable(
                                preset.id
                            )
                        ) BeautificationAssetStatus.Available else BeautificationAssetStatus.NotDownloaded,
                        isSelected = false,
                    )
                }
            ),
            showSaveButton = config.showSaveButton,
        )
    }

    override fun mapChannelInfo(channel: GetChannelResponse.Channel) = ChannelInfoUiModel(
        channelId = channel.basic.channelId,
        title = channel.basic.title,
        description = channel.basic.description,
        ingestUrl = channel.medias.firstOrNull { it.id == channel.basic.activeMediaID }?.ingestUrl.orEmpty(),
        coverUrl = channel.basic.coverUrl,
        status = ChannelStatus.getByValue(channel.basic.status.id)
    )

    override fun mapChannelSchedule(
        timestamp: GetChannelResponse.Timestamp,
        status: GetChannelResponse.ChannelBasicStatus
    ): BroadcastScheduleUiModel {
        return if (timestamp.publishedAt.isBlank() || ChannelStatus.getByValue(status.id) == ChannelStatus.Live) BroadcastScheduleUiModel.NoSchedule
        else {
            val scheduleDate = timestamp.publishedAt.toDateWithFormat(DATE_FORMAT_RFC3339)
            BroadcastScheduleUiModel.Scheduled(
                time = scheduleDate,
                formattedTime = scheduleDate.toFormattedString(
                    DATE_FORMAT_BROADCAST_SCHEDULE,
                    Locale("id", "ID")
                )
            )
        }
    }

    override fun mapCover(setupCover: PlayCoverUiModel?, coverUrl: String): PlayCoverUiModel {
        val prevSource = when (val prevCover = setupCover?.croppedCover) {
            is CoverSetupState.Cropped -> prevCover.coverSource
            else -> null
        }

        return PlayCoverUiModel(
            croppedCover = CoverSetupState.Cropped.Uploaded(
                localImage = null,
                coverImage = uriParser.parse(coverUrl),
                coverSource = prevSource ?: CoverSource.None
            ),
            state = SetupDataState.Uploaded,
        )
    }

    override fun mapShareInfo(channel: GetChannelResponse.Channel) = ShareUiModel(
        id = channel.basic.channelId,
        title = channel.share.metaTitle,
        description = channel.share.metaDescription,
        imageUrl = channel.basic.coverUrl,
        textContent = textTransformer.transform(channel.share.text),
        redirectUrl = channel.share.redirectURL,
        shortenUrl = channel.share.useShortURL
    )

    override fun mapChannelSummary(
        title: String,
        coverUrl: String,
        date: String,
        duration: String,
        author: ContentAccountUiModel,
    ) = ChannelSummaryUiModel(
        title = title,
        coverUrl = coverUrl,
        date = date,
        duration = duration,
        author = author,
    )

    override fun mapIncomingChat(chat: Chat): PlayChatUiModel = PlayChatUiModel(
        messageId = chat.messageId,
        message = chat.message,
        userId = chat.user.id,
        name = chat.user.name,
        isSelfMessage = false
    )

    override fun mapFreezeEvent(freezeEvent: Freeze, event: EventUiModel?): EventUiModel =
        EventUiModel(
            freeze = freezeEvent.isFreeze,
            banned = event?.banned ?: false,
            title = event?.title.orEmpty(),
            message = event?.message.orEmpty(),
            buttonTitle = event?.buttonTitle.orEmpty()
        )

    override fun mapBannedEvent(bannedEvent: Banned, event: EventUiModel?): EventUiModel =
        EventUiModel(
            freeze = event?.freeze ?: false,
            banned = true,
            title = bannedEvent.title,
            message = bannedEvent.reason,
            buttonTitle = bannedEvent.btnText
        )

    override fun mapInteractiveConfig(
        authorType: String,
        response: GetInteractiveConfigResponse
    ): InteractiveConfigUiModel {
        val interactiveDuration = response.interactiveConfig.tapTapConfig.interactiveDuration

        val quizDurationInMs = response.interactiveConfig.quizConfig.quizDurationsInSeconds.map {
            TimeUnit.SECONDS.toMillis(it.toLong())
        }

        return InteractiveConfigUiModel(
            giveawayConfig = GiveawayConfigUiModel(
                isActive = if (authorType == TYPE_SHOP) response.interactiveConfig.tapTapConfig.isActive else false,
                nameGuidelineHeader = response.interactiveConfig.tapTapConfig.interactiveNamingGuidelineHeader,
                nameGuidelineDetail = response.interactiveConfig.tapTapConfig.interactiveNamingGuidelineDetail,
                timeGuidelineHeader = response.interactiveConfig.tapTapConfig.interactiveTimeGuidelineHeader,
                timeGuidelineDetail = response.interactiveConfig.tapTapConfig.interactiveTimeGuidelineDetail
                    .replace(FORMAT_INTERACTIVE_DURATION, interactiveDuration.toString()),
                durationInMs = TimeUnit.SECONDS.toMillis(interactiveDuration.toLong()),
                availableStartTimeInMs = response.interactiveConfig.tapTapConfig.countdownPickerTime.map {
                    TimeUnit.SECONDS.toMillis(it.toLong())
                },
            ),
            quizConfig = QuizConfigUiModel(
                isActive = if (authorType == TYPE_SHOP) response.interactiveConfig.quizConfig.isActive else false,
                isGiftActive = authorType == TYPE_SHOP,
                maxTitleLength = response.interactiveConfig.quizConfig.maxTitleLength,
                maxChoicesCount = response.interactiveConfig.quizConfig.maxChoicesCount,
                minChoicesCount = response.interactiveConfig.quizConfig.minChoicesCount,
                maxChoiceLength = response.interactiveConfig.quizConfig.maxChoiceLength,
                availableStartTimeInMs = quizDurationInMs,
                eligibleStartTimeInMs = quizDurationInMs,
            ),
        )
    }

    override fun mapInteractiveSession(
        response: PostInteractiveCreateSessionResponse,
        title: String,
        durationInMs: Long
    ): InteractiveSessionUiModel {
        return InteractiveSessionUiModel(
            response.interactiveSellerCreateSession.data.interactiveId,
            title,
            durationInMs
        )
    }

    override fun mapPinnedMessage(
        response: GetPinnedMessageResponse.Data
    ): List<PinnedMessageUiModel> {
        return response.pinnedMessages.map {
            PinnedMessageUiModel(
                id = it.id,
                message = it.message,
                isActive = it.status.id == 1,
                editStatus = PinnedMessageEditStatus.Nothing
            )
        }
    }

    override fun mapPinnedMessageSocket(response: PinnedMessageSocketResponse): PinnedMessageUiModel {
        return PinnedMessageUiModel(
            id = response.pinnedMessageId,
            message = response.title,
            isActive = true,
            editStatus = PinnedMessageEditStatus.Nothing,
        )
    }

    override fun mapQuizOptionToChoice(option: QuizFormDataUiModel.Option): PostInteractiveCreateQuizUseCase.Choice {
        return PostInteractiveCreateQuizUseCase.Choice(
            text = option.text,
            correct = option.isSelected
        )
    }

    override fun mapQuizDetail(
        response: GetInteractiveQuizDetailResponse,
        interactiveId: String
    ): QuizDetailDataUiModel {
        return with(response.playInteractiveQuizDetail) {
            QuizDetailDataUiModel(
                question = textTransformer.transform(question),
                reward = textTransformer.transform(reward),
                countDownEnd = countdownEnd,
                choices = choices.map {
                    QuizDetailDataUiModel.Choice(
                        id = it.id,
                        text = textTransformer.transform(it.text),
                        isCorrectAnswer = it.isCorrectAnswer,
                        participantCount = it.participantCount
                    )
                },
                interactiveId = interactiveId,
            )
        }
    }

    override fun mapQuizDetailToLeaderBoard(
        dataUiModel: QuizDetailDataUiModel,
        endTime: Calendar?
    ): List<LeaderboardGameUiModel> {
        val choices = dataUiModel.choices.mapIndexed { index, choice ->
            LeaderboardGameUiModel.QuizOption(
                QuizChoicesUiModel(
                    index = index,
                    id = choice.id,
                    text = textTransformer.transform(choice.text),
                    type = PlayQuizOptionState.Participant(
                        alphabet = generateAlphabetChoices(index),
                        isCorrect = choice.isCorrectAnswer,
                        count = choice.participantCount.toString(),
                        showArrow = true
                    ),
                    interactiveId = dataUiModel.interactiveId,
                    interactiveTitle = textTransformer.transform(dataUiModel.question),
                )
            )
        }
        return mutableListOf<LeaderboardGameUiModel>().apply {
            add(
                LeaderboardGameUiModel.Header(
                    title = dataUiModel.question,
                    endsIn = endTime,
                    leaderBoardType = LeadeboardType.Quiz,
                    id = dataUiModel.interactiveId
                )
            )
            addAll(choices)
        }
    }

    override fun mapChoiceDetail(
        response: GetInteractiveQuizChoiceDetailResponse,
        choiceIndex: Int,
        interactiveId: String,
        interactiveTitle: String,
    ): QuizChoiceDetailUiModel {
        return with(response.playInteractiveQuizChoiceDetail) {
            QuizChoiceDetailUiModel(
                choice = QuizChoicesUiModel(
                    index = choiceIndex,
                    id = choice.id,
                    text = textTransformer.transform(choice.text),
                    type = PlayQuizOptionState.Participant(
                        generateAlphabetChoices(choiceIndex),
                        choice.isCorrectAnswer,
                        "${choice.participantCount} Respon",
                        false,
                    ),
                    interactiveId = interactiveId,
                    interactiveTitle = interactiveTitle,
                ),
                cursor = cursor,
                winners = winners.map {
                    GameParticipantUiModel(
                        id = it.id,
                        name = it.firstName,
                        imageUrl = it.imageURL,
                        isWinner = true
                    )
                },
                participants = participants.map {
                    GameParticipantUiModel(
                        id = it.id,
                        name = it.firstName,
                        imageUrl = it.imageURL,
                        isWinner = false
                    )
                },
            )
        }
    }

    @OptIn(ExperimentalStdlibApi::class)
    override fun mapLeaderBoardWithSlot(
        response: GetSellerLeaderboardSlotResponse,
        allowChat: Boolean
    ): List<LeaderboardGameUiModel> {
        return buildList {
            response.data.slots.forEach {
                //Header
                add(
                    LeaderboardGameUiModel.Header(
                        id = it.interactiveId,
                        reward = if (getLeaderboardType(it.type) == LeadeboardType.Quiz) "" else textTransformer.transform(
                            it.reward
                        ),
                        leaderBoardType = getLeaderboardType(it.type),
                        title = it.getSlotTitle()
                    )
                )

                // Quiz if any
                if (it.choices.isNotEmpty()) addAll(it.choices.mapIndexed { index, choice ->
                    LeaderboardGameUiModel.QuizOption(
                        QuizChoicesUiModel(
                            index = index,
                            id = choice.id,
                            text = textTransformer.transform(choice.text),
                            type = PlayQuizOptionState.Participant(
                                alphabet = generateAlphabetChoices(index),
                                isCorrect = choice.isCorrectAnswer,
                                count = choice.participantCount.toString(),
                                showArrow = true
                            ),
                            interactiveId = it.interactiveId,
                            interactiveTitle = it.getSlotTitle()
                        )
                    )
                })

                //Winner if any
                if (it.winner.isNotEmpty()) addAll(
                    it.winner.mapIndexed { index, winner ->
                        LeaderboardGameUiModel.Winner(
                            rank = index + 1,
                            id = winner.userID,
                            name = winner.userName,
                            imageUrl = winner.imageUrl,
                            allowChat = { allowChat },
                            topChatMessage =
                            if (getLeaderboardType(it.type) == LeadeboardType.Giveaway)
                                response.data.config.topchatMessage
                                    .replace(FORMAT_FIRST_NAME, winner.userName)
                                    .replace(FORMAT_TITLE, it.getSlotTitle())
                            else
                                response.data.config.topchatMessageQuiz
                                    .replace(FORMAT_FIRST_NAME, winner.userName)
                                    .replace(FORMAT_TITLE, it.getSlotTitle()),
                        )
                    }
                )
                // need to add topChat

                //Footer
                add(
                    LeaderboardGameUiModel.Footer(
                        otherParticipantText = it.otherParticipantCountText,
                        otherParticipant = it.otherParticipantCount.toLong(),
                        leaderBoardType = getLeaderboardType(it.type),
                        totalParticipant = it.winner.size.toLong(),
                        emptyLeaderBoardCopyText = "", //in bro GQL no empty leaderboard
                        id = it.interactiveId,
                    )
                )
            }
        }
    }

    private fun GetSellerLeaderboardSlotResponse.SlotData.getSlotTitle(): String {
        return if (getLeaderboardType(this.type) == LeadeboardType.Giveaway)
            this.title
        else textTransformer.transform(
            this.question
        )
    }

    private fun generateAlphabetChoices(index: Int): Char = arrayOfChoices[index]
    private val arrayOfChoices = ('A'..'D').toList()

    /***
     * Change to typename to make sure
     */
    private fun getLeaderboardType(leaderboardsResponse: String): LeadeboardType {
        return when (leaderboardsResponse) {
            "PlayInteractiveSellerLeaderboardGiveaway" -> LeadeboardType.Giveaway
            "PlayInteractiveSellerLeaderboardQuiz" -> LeadeboardType.Quiz
            else -> LeadeboardType.Unknown
        }
    }

    override fun mapBroadcasterMetric(
        metric: BroadcasterMetric,
        authorId: String,
        channelId: String
    ) = PlayBroadcasterMetric(
        authorId = authorId,
        channelId = channelId,
        videoBitrate = metric.videoBitrate,
        audioBitrate = metric.audioBitrate,
        resolution = "${metric.resolutionWidth}x${metric.resolutionHeight}",
        traffic = metric.traffic,
        bandwidth = metric.bandwidth,
        fps = metric.fps,
        packetLossIncreased = metric.packetLossIncreased,
        videoBufferTimestamp = metric.videoBufferTimestamp,
        audioBufferTimestamp = metric.audioBufferTimestamp,
    )

    override fun mapAuthorList(response: Creation): List<ContentAccountUiModel> {
        return response.authors.map {
            ContentAccountUiModel(
                id = it.id,
                name = it.name,
                iconUrl = it.image,
                type = it.type,
                hasUsername = it.hasUsername,
                hasAcceptTnc = it.hasAcceptTnC,
                enable = response.isActive,
            )
        }
    }

    override fun mapGeneratedCover(response: GetGeneratedImageCoverResponse): GeneratedCoverUiModel {
        return GeneratedCoverUiModel(
            imageUrl = response.imageGeneratorGenerateImage.imageUrl,
            sourceId = response.imageGeneratorGenerateImage.sourceId,
        )
    }

    override fun mapTickerBottomSheetConfig(
        response: GetTickerBottomSheetResponse
    ): TickerBottomSheetUiModel = with(response.data) {
        return TickerBottomSheetUiModel(
            page = when (page) {
                GetTickerBottomSheetResponse.PAGE_PREPARATION -> TickerBottomSheetPage.LIVE_PREPARATION
                GetTickerBottomSheetResponse.PAGE_REPORT -> TickerBottomSheetPage.LIVE_REPORT
                else -> TickerBottomSheetPage.UNKNOWN
            },
            type = when (type) {
                GetTickerBottomSheetResponse.TYPE_BOTTOM_SHEET -> TickerBottomSheetType.BOTTOM_SHEET
                GetTickerBottomSheetResponse.TYPE_TICKER -> TickerBottomSheetType.TICKER
                else -> TickerBottomSheetType.UNKNOWN
            },
            imageURL = imageURL,
            cacheKey = cacheKey,
            bottomText = TickerBottomSheetUiModel.BottomText(
                action = bottomText.action.map { action ->
                    TickerBottomSheetUiModel.Action(
                        item = action.index,
                        text = action.text,
                        link = action.link,
                    )
                },
                description = bottomText.description,
            ),
            mainText = mainText.map { mainText ->
                TickerBottomSheetUiModel.MainText(
                    action = mainText.action.map { action ->
                        TickerBottomSheetUiModel.Action(
                            item = action.index,
                            text = action.text,
                            link = action.link,
                        )
                    },
                    title = mainText.title,
                    description = mainText.description,
                )
            }
        )
    }

    override fun mapReportSummary(
        response: GetReportSummaryResponse,
        isAuthorShop: Boolean
    ): LiveReportSummaryUiModel {
        val data =
            response.data.reportData.getOrNull(0)?.content ?: return LiveReportSummaryUiModel.Empty

        val liveStats = if (isAuthorShop) {
            listOf(
                LiveStatsUiModel.Viewer(data.metrics.liveConcurrentUsers),
                LiveStatsUiModel.TotalViewer(data.metrics.visitContent),
                LiveStatsUiModel.EstimatedIncome(data.metrics.estimatedIncome),
                LiveStatsUiModel.Like(data.metrics.totalLike),
            )
        } else {
            listOf(
                LiveStatsUiModel.Viewer(data.metrics.liveConcurrentUsers),
                LiveStatsUiModel.TotalViewer(data.metrics.visitContent),
                LiveStatsUiModel.Like(data.metrics.totalLike),
            )
        }

        return LiveReportSummaryUiModel(
            liveStats = liveStats,
            timestamp = response.data.timestamp,
        )
    }

    override fun mapReportProductSummary(response: GetReportProductSummaryResponse): ProductReportSummaryUiModel {
        return ProductReportSummaryUiModel(
            totalStatsList = listOf(
                LiveStatsUiModel.EstimatedIncome(response.data.reportProductAggregate.estimatedIncome),
                LiveStatsUiModel.Visit(response.data.reportProductAggregate.visitPdp),
                LiveStatsUiModel.AddToCart(response.data.reportProductAggregate.addToCart),
                LiveStatsUiModel.TotalSold(response.data.reportProductAggregate.productSoldQty),
            ),
            productStatsList = response.data.reportProductMetricsWithDetail.map {
                ProductStatsUiModel(
                    id = it.productId,
                    name = it.productName,
                    imageUrl = it.productImageURL,
                    addToCart = it.reportProductMetric.addToCart,
                    estimatedIncome = it.reportProductMetric.estimatedIncome,
                    visitPdp = it.reportProductMetric.visitPdp,
                    productSoldQty = it.reportProductMetric.productSoldQty,
                )
            }
        )
    }

    companion object {
        private const val FORMAT_INTERACTIVE_DURATION = "${'$'}{second}"
        private const val FORMAT_FIRST_NAME = "{{first_name}}"
        private const val FORMAT_TITLE = "{{title}}"
    }
}
